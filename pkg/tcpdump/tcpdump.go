package tcpdump

import (
	"bufio"
	"context"
	"fmt"
	"log"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/jordan-wright/ossmalware/pkg/docker"
	"github.com/jordan-wright/ossmalware/pkg/library"
)

type Container struct {
	name        string
	containerID string
	cli         docker.DockerClient
	ctx         context.Context
}

func (tc *Container) NetworkMode() container.NetworkMode {
	return container.NetworkMode(fmt.Sprintf("container:%s", tc.name))
}

func (tc *Container) Stop() error {
	log.Printf("Stopping %s container", tc.name)
	err := tc.cli.ContainerStop(tc.ctx, tc.containerID, nil)
	if err != nil {
		return err
	}

	log.Printf("Removing %s container", tc.name)
	err = tc.cli.ContainerRemove(tc.ctx, tc.containerID, types.ContainerRemoveOptions{})
	if err != nil {
		return err
	}
	return nil
}

// generateCmd generates the correct tcpdump command, setting up a filter to
// ignore hosts as needed.
func generateCmd(pcapFilename string, ignoredHosts ...string) []string {
	cmd := []string{"tcpdump", "-w", fmt.Sprintf("/opt/%s", pcapFilename)}
	ignoreList := []string{}
	for _, host := range ignoredHosts {
		ignoreList = append(ignoreList, fmt.Sprintf("not host %s", host))
	}
	cmd = append(cmd, strings.Join(ignoreList, " and "))
	log.Printf("tcpdump command: %#v", cmd)
	return cmd
}

func Run(ctx context.Context, cli docker.DockerClient, name, pcapPath string, ignoredHosts ...string) (*Container, error) {
	pcapFilename := filepath.Base(pcapPath)
	cmd := generateCmd(pcapFilename, ignoredHosts...)
	pcapDir := filepath.Dir(pcapPath)
	resp, err := cli.ContainerCreate(ctx, &container.Config{
		Image: "tcpdump",
		Tty:   false,
		Cmd:   cmd,
	}, &container.HostConfig{Binds: []string{fmt.Sprintf("%s:/opt/:rw", pcapDir)}}, nil, name)

	if err != nil {
		return nil, err
	}

	log.Printf("Starting %s container", name)
	if err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {
		return nil, err
	}
	return &Container{
		name:        name,
		containerID: resp.ID,
		cli:         cli,
		ctx:         ctx,
	}, nil
}

func ParseLookups(filepath string) ([]library.DNSLookup, error) {
	lookups := []library.DNSLookup{}
	cmd := exec.Command("tshark", "-r", filepath, "-n", "-T", "fields", "-e", "dns.qry.name", "-e", "dns.resp.addr", "(dns && dns.flags.response==1)")
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return lookups, err
	}
	err = cmd.Start()
	if err != nil {
		return nil, fmt.Errorf("error running tcpdump: %w", err)
	}
	scanner := bufio.NewScanner(stdout)
	cache := map[string]bool{}
	for scanner.Scan() {
		fields := strings.Split(scanner.Text(), "\t")
		if len(fields) != 2 {
			continue
		}
		name := fields[0]
		if _, ok := cache[name]; ok {
			continue
		}
		addresses := strings.Split(fields[1], ",")
		if len(addresses) == 0 {
			continue
		}
		cache[name] = true
		lookups = append(lookups, library.DNSLookup{
			Name:        name,
			IPAddresses: addresses,
		})
	}
	cmd.Wait()
	return lookups, nil
}
